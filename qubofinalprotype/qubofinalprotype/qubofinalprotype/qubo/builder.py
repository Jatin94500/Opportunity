"""Drag-and-drop circuit builder utilities.

Provides a simple representation for gates and a helper to generate Python
code that reconstructs a circuit. This keeps code-generation testable without
requiring a GUI context.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Sequence

TWO_QUBIT_GATES = {"CNOT", "SWAP"}


@dataclass
class BuiltGate:
    name: str
    targets: List[int]
    params: List[float] = field(default_factory=list)

    def to_code(self) -> str:
        if self.params:
            # paramized single-qubit rotations like RZ, RX, RY
            pstr = ", params=[" + ", ".join(repr(p) for p in self.params) + "]"
        else:
            pstr = ""
        return f"qc.add_gate('{self.name}', targets={self.targets}{pstr})"


def gate_requires_two_qubits(name: str) -> bool:
    return name.upper() in TWO_QUBIT_GATES


def generate_circuit_code(num_qubits: int, gates: Sequence[BuiltGate]) -> str:
    """Return executable Python code for a list of built gates."""
    lines = [
        "from qubo.circuit import QuantumCircuit",
        "# Auto-generated by drag-and-drop builder",
        f"qc = QuantumCircuit({int(num_qubits)})",
    ]
    for g in gates:
        lines.append(g.to_code())
    return "\n".join(lines) + "\n"


__all__ = ["BuiltGate", "generate_circuit_code", "gate_requires_two_qubits"]
